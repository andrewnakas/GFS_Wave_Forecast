<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GFS Wave Velocity</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #000;
            cursor: crosshair;
        }

        .leaflet-container {
            background: #000 !important;
        }

        /* Make velocity particles wider/thicker for wave-like appearance */
        canvas.leaflet-zoom-animated {
            image-rendering: auto;
        }

        /* Custom pin marker */
        .forecast-marker {
            width: 30px;
            height: 30px;
            background: rgba(244, 109, 67, 0.9);
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
        }

        .forecast-marker::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Forecast panel */
        .forecast-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100%;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            color: #fff;
            transition: right 0.3s ease;
            z-index: 2000;
            overflow-y: auto;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }

        .forecast-panel.open {
            right: 0;
        }

        .forecast-header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .forecast-header h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .forecast-location {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 4px;
        }

        .close-forecast {
            position: absolute;
            right: 20px;
            top: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .close-forecast:hover {
            opacity: 1;
        }

        .forecast-content {
            padding: 20px;
        }

        .forecast-chart {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-title {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .forecast-day {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .forecast-day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .forecast-date {
            font-weight: 600;
            font-size: 14px;
        }

        .forecast-day-name {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        .forecast-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .metric {
            display: flex;
            flex-direction: column;
        }

        .metric-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: 600;
        }

        .metric-unit {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 4px;
        }

        .wave-height-large {
            color: #f46d43;
        }

        .wave-height-medium {
            color: #fee08b;
        }

        .wave-height-small {
            color: #66c2a5;
        }

        /* Loading state */
        .forecast-loading {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Click indicator */
        .click-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 13px;
            z-index: 1000;
            pointer-events: none;
            animation: fadeInOut 3s ease-in-out infinite;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Forecast Panel -->
    <div id="forecastPanel" class="forecast-panel">
        <div class="forecast-header">
            <button class="close-forecast" onclick="closeForecast()">&times;</button>
            <h2>10-Day Wave Forecast</h2>
            <div class="forecast-location" id="forecastLocation">Select a location</div>
        </div>
        <div class="forecast-content" id="forecastContent">
            <div class="forecast-chart" id="forecastChart" style="display: none;">
                <div class="chart-title">10-Day Wave Height Forecast</div>
                <canvas id="waveChart"></canvas>
            </div>
            <div id="forecastDays">
                <div class="forecast-loading">Click anywhere on the map to view wave forecast</div>
            </div>
        </div>
    </div>

    <!-- Click hint -->
    <div class="click-hint">Click on the ocean to view 10-day wave forecast</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-velocity@1.9.0/dist/leaflet-velocity.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/topojson@3/dist/topojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="wave-data.js"></script>
    <script>
        // Initialize map
        const map = L.map('map', {
            center: [20, 0],
            zoom: 2,
            zoomControl: true,
            attributionControl: false
        });

        // Add dark tiles
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);

        // Wait for both map and wave data to be ready
        let mapReady = false;
        let dataReady = false;
        let currentMarker = null;
        let landPolygons = null;
        let waveChart = null;

        function tryInitVelocity() {
            if (mapReady && dataReady && window.waveData) {
                console.log('Initializing velocity layer...');

                const velocityLayer = L.velocityLayer({
                    displayValues: true,
                    displayOptions: {
                        velocityType: 'Wave',
                        position: 'bottomleft',
                        emptyString: 'No wave data',
                        showCardinal: true,
                        speedUnit: 'm/s'
                    },
                    data: window.waveData,
                    maxVelocity: 10,
                    velocityScale: 0.015,
                    particleMultiplier: 1/300,
                    lineWidth: 6, // Much wider lines for hamburger-style wave appearance
                    colorScale: [
                        '#3288bd',
                        '#66c2a5',
                        '#abdda4',
                        '#e6f598',
                        '#fee08b',
                        '#fdae61',
                        '#f46d43',
                        '#d53e4f'
                    ]
                });

                velocityLayer.addTo(map);
                console.log('Wave velocity layer added successfully');
            }
        }

        // Load land polygons from Natural Earth data
        async function loadLandPolygons() {
            try {
                console.log('Loading land polygons from Natural Earth...');
                const response = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json');
                const data = await response.json();

                // Convert TopoJSON to GeoJSON
                landPolygons = topojson.feature(data, data.objects.land);
                console.log('Land polygons loaded successfully');
            } catch (error) {
                console.error('Failed to load land polygons:', error);
                // Fallback to simple approach if loading fails
                landPolygons = null;
            }
        }

        // Check if a location is on land using proper point-in-polygon testing
        function isLand(lat, lon) {
            if (!landPolygons) {
                return false; // If polygons not loaded, allow all clicks
            }

            try {
                // Create turf point (note: turf uses [lon, lat] order!)
                const point = turf.point([lon, lat]);

                // Check if point is within any land polygon
                return turf.booleanPointInPolygon(point, landPolygons);
            } catch (error) {
                console.error('Error in land detection:', error);
                return false; // On error, allow the click
            }
        }

        // Generate 10-day wave forecast for a location
        function generateForecast(lat, lon) {
            const forecast = [];
            const now = new Date();

            for (let day = 0; day < 10; day++) {
                const date = new Date(now);
                date.setDate(date.getDate() + day);

                // Simulate realistic wave patterns based on location
                let baseHeight = 1.5;

                // Latitude-based patterns
                const absLat = Math.abs(lat);
                if (absLat > 40) { // High latitudes - bigger waves
                    baseHeight = 3.0;
                } else if (absLat > 30) { // Mid latitudes
                    baseHeight = 2.5;
                } else if (absLat < 15) { // Tropics - smaller waves
                    baseHeight = 1.2;
                }

                // Add temporal variation
                const variation = Math.sin((day / 10) * Math.PI * 2) * 1.5;
                const waveHeight = Math.max(0.5, baseHeight + variation + (Math.random() - 0.5) * 0.8);

                // Period correlates with height
                const period = 6 + waveHeight * 2 + (Math.random() - 0.5) * 2;

                // Direction varies
                const direction = (180 + day * 15 + (Math.random() - 0.5) * 60) % 360;

                forecast.push({
                    date: date,
                    waveHeight: waveHeight,
                    period: period,
                    direction: direction,
                    windSpeed: 10 + waveHeight * 3 + (Math.random() - 0.5) * 5
                });
            }

            return forecast;
        }

        // Get direction name from degrees
        function getDirectionName(degrees) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        // Get wave height color class
        function getWaveHeightClass(height) {
            if (height >= 3) return 'wave-height-large';
            if (height >= 1.5) return 'wave-height-medium';
            return 'wave-height-small';
        }

        // Render wave height chart
        function renderWaveChart(forecast) {
            const ctx = document.getElementById('waveChart').getContext('2d');

            // Destroy existing chart if it exists
            if (waveChart) {
                waveChart.destroy();
            }

            // Prepare data
            const labels = forecast.map((day, index) => {
                if (index === 0) return 'Today';
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                return days[day.date.getDay()];
            });

            const waveHeights = forecast.map(day => day.waveHeight);

            // Create gradient for wave height
            const gradient = ctx.createLinearGradient(0, 0, 0, 200);
            gradient.addColorStop(0, 'rgba(244, 109, 67, 0.8)');
            gradient.addColorStop(0.5, 'rgba(254, 224, 139, 0.6)');
            gradient.addColorStop(1, 'rgba(102, 194, 165, 0.4)');

            // Create chart
            waveChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Wave Height (m)',
                        data: waveHeights,
                        borderColor: 'rgba(102, 194, 165, 1)',
                        backgroundColor: gradient,
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: waveHeights.map(h => {
                            if (h >= 3) return '#f46d43';
                            if (h >= 1.5) return '#fee08b';
                            return '#66c2a5';
                        }),
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2.5,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            borderWidth: 1,
                            padding: 10,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return `Wave Height: ${context.parsed.y.toFixed(1)}m`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)',
                                drawBorder: false
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.6)',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return value + 'm';
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.6)',
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });

            // Show chart container
            document.getElementById('forecastChart').style.display = 'block';
        }

        // Display forecast in panel
        function showForecast(lat, lon) {
            const panel = document.getElementById('forecastPanel');
            const location = document.getElementById('forecastLocation');
            const forecastDays = document.getElementById('forecastDays');

            // Remove previous marker if exists
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }

            // Add new pin marker
            const icon = L.divIcon({
                className: 'forecast-marker',
                iconSize: [30, 30],
                iconAnchor: [15, 30],
                popupAnchor: [0, -30]
            });

            currentMarker = L.marker([lat, lon], { icon: icon }).addTo(map);

            // Update location
            location.textContent = `${lat.toFixed(2)}°${lat >= 0 ? 'N' : 'S'}, ${lon.toFixed(2)}°${lon >= 0 ? 'E' : 'W'}`;

            // Generate forecast
            const forecast = generateForecast(lat, lon);

            // Render chart with forecast data
            renderWaveChart(forecast);

            // Build HTML
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            let html = '';
            forecast.forEach((day, index) => {
                const dayName = days[day.date.getDay()];
                const monthName = months[day.date.getMonth()];
                const dateStr = `${monthName} ${day.date.getDate()}`;

                html += `
                    <div class="forecast-day">
                        <div class="forecast-day-header">
                            <div>
                                <div class="forecast-date">${index === 0 ? 'Today' : dayName}</div>
                                <div class="forecast-day-name">${dateStr}</div>
                            </div>
                        </div>
                        <div class="forecast-metrics">
                            <div class="metric">
                                <div class="metric-label">Wave Height</div>
                                <div class="metric-value ${getWaveHeightClass(day.waveHeight)}">
                                    ${day.waveHeight.toFixed(1)}<span class="metric-unit">m</span>
                                </div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Period</div>
                                <div class="metric-value">
                                    ${day.period.toFixed(1)}<span class="metric-unit">s</span>
                                </div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Direction</div>
                                <div class="metric-value">
                                    ${getDirectionName(day.direction)}<span class="metric-unit">${Math.round(day.direction)}°</span>
                                </div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Wind Speed</div>
                                <div class="metric-value">
                                    ${day.windSpeed.toFixed(1)}<span class="metric-unit">kts</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            forecastDays.innerHTML = html;
            panel.classList.add('open');
        }

        // Close forecast panel
        function closeForecast() {
            document.getElementById('forecastPanel').classList.remove('open');

            // Remove marker when closing forecast
            if (currentMarker) {
                map.removeLayer(currentMarker);
                currentMarker = null;
            }
        }

        // Handle map clicks
        map.on('click', function(e) {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;

            // Check if clicked location is on land
            if (isLand(lat, lon)) {
                console.log('Clicked on land - no forecast available');
                // Optionally show a message
                const panel = document.getElementById('forecastPanel');
                if (panel.classList.contains('open')) {
                    closeForecast();
                }
                return;
            }

            // Show forecast for ocean location
            showForecast(lat, lon);
        });

        map.whenReady(function() {
            console.log('Map ready');
            mapReady = true;
            tryInitVelocity();
        });

        window.addEventListener('waveDataReady', function() {
            console.log('Wave data ready');
            dataReady = true;
            tryInitVelocity();
        });

        // Load land polygons for accurate land detection
        loadLandPolygons();
    </script>
</body>
</html>
